# Importing required libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf
from scipy.stats import norm

# Fetch historical data for a single ticker
def fetch_data(ticker, start, end):
    data = yf.download(ticker, start=start, end=end)['Adj Close']
    return data

# Calculate logarithmic returns based on frequency
def preprocess_data(data, frequency='daily'):
    if frequency == 'daily':
        log_returns = np.log(data / data.shift(1))
    elif frequency == 'weekly':
        log_returns = np.log(data.resample('W').last() / data.resample('W').last().shift(1))
    elif frequency == 'monthly':
        log_returns = np.log(data.resample('M').last() / data.resample('M').last().shift(1))
    log_returns = log_returns.dropna()
    return log_returns

# Monte Carlo simulation to estimate future returns
def monte_carlo_simulation(returns, num_simulations=10000):
    mean = returns.mean()
    std_dev = returns.std()
    simulated_returns = np.random.normal(mean, std_dev, (num_simulations, len(returns)))
    return simulated_returns

# Calculate historical VaR and CVaR
def calculate_historical_var_cvar(returns, confidence_level=95):
    var = -np.percentile(returns, 100 - confidence_level)
    losses = -returns
    var_threshold = np.percentile(losses, confidence_level)
    cvar = losses[losses >= var_threshold].mean()
    return var, cvar

# Calculate parametric VaR and CVaR
def calculate_parametric_var_cvar(returns, confidence_level=95):
    mean = returns.mean()
    std_dev = returns.std()
    var = -norm.ppf(1 - confidence_level / 100) * std_dev + mean
    cvar = -mean + std_dev * norm.pdf(norm.ppf(confidence_level / 100)) / (1 - confidence_level / 100)
    return var, cvar

# Calculate VaR and CVaR using Monte Carlo simulation
def calculate_monte_carlo_var_cvar(simulated_returns, confidence_level=95):
    var = -np.percentile(simulated_returns, 100 - confidence_level, axis=0)
    losses = -simulated_returns
    var_threshold = np.percentile(losses, confidence_level, axis=0)
    cvar = losses[losses >= var_threshold].mean(axis=0)
    return var, cvar

# Main function to calculate and display VaR and CVaR
def main():
    # User inputs
    ticker = 'ETH-USD'  # Ticker for Ethereum
    start_date = '2019-01-01'  # Start date for data retrieval
    end_date = '2023-01-01'  # End date for data retrieval
    frequency = 'monthly'  # Options: 'daily', 'weekly', 'monthly'
    confidence_level = 99  # Options: 95, 99
    method = 'historical'  # Options: 'historical', 'parametric', 'monte carlo'
    
    # Fetch and preprocess data
    data = fetch_data(ticker, start=start_date, end=end_date)
    log_returns = preprocess_data(data, frequency)
    
    # Check data
    print(f"Data for {ticker} from {start_date} to {end_date} with {frequency} frequency:")
    print(log_returns.describe())
    
    # Calculate VaR and CVaR based on selected method
    if method == 'historical':
        var, cvar = calculate_historical_var_cvar(log_returns, confidence_level)
    elif method == 'parametric':
        var, cvar = calculate_parametric_var_cvar(log_returns, confidence_level)
    elif method == 'monte carlo':
        simulated_returns = monte_carlo_simulation(log_returns)
        var, cvar = calculate_monte_carlo_var_cvar(simulated_returns, confidence_level)
    
    # Convert var and cvar to scalar values if they are arrays
    if isinstance(var, np.ndarray):
        var = var.mean()
    if isinstance(cvar, np.ndarray):
        cvar = cvar.mean()
    
    # Display results
    print(f"\n{frequency.capitalize()} VaR and CVaR for {ticker} at {confidence_level}% confidence level using {method.capitalize()} method:")
    print(f"VaR: {var:.4f}")
    print(f"CVaR: {cvar:.4f}")
    
    # Visualization
    plt.figure(figsize=(14, 7))
    
    # Plot log returns
    plt.subplot(2, 2, 1)
    plt.plot(log_returns, color='blue')
    plt.title(f'{frequency.capitalize()} Log Returns of {ticker}')
    plt.xlabel('Date')
    plt.ylabel('Log Returns')
    
    # Plot histogram of returns or simulated returns based on the method
    plt.subplot(2, 2, 2)
    if method == 'monte carlo':
        plt.hist(simulated_returns.flatten(), bins=50, color='blue', alpha=0.7)
    else:
        plt.hist(log_returns, bins=50, color='blue', alpha=0.7)
    plt.title('Histogram of Returns')
    plt.xlabel('Returns')
    plt.ylabel('Frequency')
    
    # Plot VaR
    plt.subplot(2, 2, 3)
    if method == 'monte carlo':
        plt.hist(simulated_returns.flatten(), bins=50, color='blue', alpha=0.7)
    else:
        plt.hist(log_returns, bins=50, color='blue', alpha=0.7)
    plt.axvline(x=-var, color='r', linestyle='--', label=f'VaR ({confidence_level}%)')
    plt.title('Value at Risk (VaR)')
    plt.xlabel('Returns')
    plt.ylabel('Frequency')
    plt.legend()
    
    # Plot CVaR
    plt.subplot(2, 2, 4)
    if method == 'monte carlo':
        plt.hist(simulated_returns.flatten(), bins=50, color='blue', alpha=0.7)
    else:
        plt.hist(log_returns, bins=50, color='blue', alpha=0.7)
    plt.axvline(x=-cvar, color='g', linestyle='--', label=f'CVaR ({confidence_level}%)')
    plt.title('Conditional Value at Risk (CVaR)')
    plt.xlabel('Returns')
    plt.ylabel('Frequency')
    plt.legend()
    
    plt.tight_layout()
    plt.show()

# Run the main function
if __name__ == "__main__":
    main()
